## 퀵 정렬

#### 재귀 - 분할 정복 알고리즘으로 구현한다.

1. 왼쪽 커서와 오른쪽 커서를 범위 값으로 초기화 한다.
    ```
        int pl = left;
        int pr = right;
        int x = a[(pl + pr)/2]; // 피벗
    ```
2. 왼쪽 커서가 위치한 요소와 Pivot을 비교한다. (오른쪽도 동시에 진행) 
3. 조건에 따라 커서 위치 변경 및 요소롤 스왑한다.
    ```
        do {
            while (a[pl] < x) pl++;
            while (a[pr] > x) pr--;
            if (pl <= pr) {
                swap(a, pl++, pr--);
            }
        }while (pl <= pr);
    ```
3. 왼쪽 커서와 오른쪽 커서가 Pivot 값을 넘어가는 순간에 반복을 중단하고 그룹을 나눈다.
4. 기존 왼쪽 커서는 나누어진 1번 그룹의 오른쪽 커서가 된다. 
5. 기존 오른쪽 커서는 나누어진 2번 그룹의 왼쪽 커서가 된다.
    ```
        if (left < pr) quickSort(a, left, pr);
        if (right > pl) quickSort(a, pl, right);
    ```
6. 반복해서 그룹을 나누고 요소가 1개가 되면 전체 과정을 멈추고 정렬된 배열을 출력한다.

#### 비재귀 - 스택을 이용해 구현한다.
    
1. 전체 과정은 재귀와 비슷하다.
2. 다른 점은 재귀는 범위를 저장하지 않고 즉시 범위 값을 변경해서 전달한다.
    ```
        if (left < pr) quickSort(a, left, pr);
        if (right > pl) quickSort(a, pl, right);
    ```
3. 스택을 이용하면 범위를 스택에 저장하고 수정하는 방식이다.
    ```
        int pl = left = lstack.pop();
        int pr = right = rstack.pop();

        .....

        if (left < pr) {
            lstack.push(left);
            rstack.push(pr);
        }

        if (pl < right) {
            lstack.push(pl);
            rstack.push(right);
        }
    ```
4. 스택을 이용한 방법은 요솟수가 다른 그룹을 푸쉬하는 순서에 따라 용량이 달라진다.
5. 요솟수가 작은 걸 먼저 처리하고 큰걸 나중에 처리하는 게 용량을 더 적게 차지한다.

#### Pivot 선택 - Pivot에 따라 시간복잡도 와 공간복잡도가 달라진다.
    
1. 배열의 중앙값
2. 임의로 3개 선택 그 중 중앙값
3. 가운데 요소 선택 > 끝에서 두번째와 스왑 > 끝에서 두번째에 위치한 요소가 피벗

#### 공간 복잡도

- 재귀 : 재귀의 깊이에 따라 달라진다. 
- 스택 : 그룹 푸쉬 순서에 따라 달라진다. (요솟수가 적은 그룹을 먼저 처리해야 용량을 덜 차지한다.)

#### 시간 복잡도
- 평균 시간 : NlogN
    - 그룹을 분할할 때 2개의 그룹으로 일어나기 때문에 log 밑은 2 
- 최악 시간 : N^2