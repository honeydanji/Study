## 힙 정렬

### 힙 정렬 방법
1. 정렬되지 않은 배열을 최대 힙으로 만든다. (내림 차순)
2. 루트(가장 큰 값)를 제거한 후에 배열의 마지막 요소에 넣는다.
3. 비어있는 루트에 힙에 가장 아래 층부터 오른쪽에 있는 요소를 넣는다.
4. 다시 힙으로 만든 뒤 루트를 제거하고 배열에 넣는다.
5. 해당과정을 반복하면 정렬된 배열이 나온다.

### 힙정렬을 사용해야 하는 문제
1. 트리와 관련있는 문제
2. 공간복잡도를 고려해야하는 문제

### 의문점 : 정렬되지 않은 배열을 굳이 힙으로 만들어서 정렬하는 이유가 뭔가?

1. 힙정렬은 내부정렬이라서 추가적인 메모리가 필요하지 않다. 즉 메모리를 효율적으로 사용 가능하다. (공간복잡도 : O(1) )
2. 퀵정렬과 병합정렬은 재귀를 이용한 정렬이라서 SOF 가 발생할 수도 있지만 힙정렬은 SOF와 관련이 없다.
3. 퀵정렬과 병합정렬은 상황(정렬상태, 요소수)에 따라서 성능이 저하될 가능성이 있지만 힙정렬은 일관성을 유지한다.
4. 힙정렬은 일관성을 유지하기 떄문에 시간복잡도와 공간복잡도는 변하지 않아 성능에 대해서 예측이 가능하다.

### 추가 고려사항
캐시 성능: Quicksort는 분할 단계로 인해 종종 좋은 캐시 성능을 나타냄.
최악의 시나리오: Quicksort의 최악의 경우는 불균형 파티션에서 발생하는 반면, mergesort 및 heap sort는 보다 일관된 성능을 제공.
병렬화: Mergesort는 분할 및 정복 특성으로 인해 병렬화에 더 적합.
무작위 퀵 정렬: 퀵 정렬의 무작위 버전은 최악의 시나리오를 완화.
